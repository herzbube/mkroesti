Project description
-------------------
* Why mkroesti
  * At first because I thought it might be useful to me, or someone else
  * In time I found utilities that do everything mkroesti is intended to do, and probably better
  * Since there is no real justification left to realize the project, I settled for "this is a learning project"

* Why "Rösti"?
  * Hash = Hash browns = Rösti
    http://en.wikipedia.org/wiki/R%C3%B6sti
    http://en.wikipedia.org/wiki/Hash_browns

* Specifications are written in the form of a manual

* Research is kept on a Wiki page

* Learning goals
  * programming in Python
  * using a Python program as CGI script
  * hashes & encodings
  * write documentation in XML and use XSLT to transform it into various formats
    * man page
    * man page / HTML
    * README
    * ...


Specification/Manual
--------------------

NAME
  mkroesti - generate different kinds of hashes

SYNOPSIS
  mkroesti [-e] [-a LIST]
  mkroesti -b [-a LIST] input
  mkroesti -f FILE [-a LIST]
  mkroesti -h

DESCRIPTION
  The mkroesti command takes an input and generates different kinds of hashes from that input. Without special instructions, mkroesti takes its input either from standard input or asks for it interactively. Unless echo mode is enabled (-e), mkroesti does not display input typed by the user, assuming that the user enters a secret password.

  Additional sources for the input are: a file (-f) or the command line (-b). Note that the latter option should be used with extreme care, since if the input is a password, it will be clearly visible on the command line.

  The user may specify one or more algorithms that should be used to generate hashes. If no specific algorithm is selected, mkroesti generates hashes for all algorithms that it knows about.

OPTIONS
  -a LIST, --algorithms LIST
    Comma separated list of algorithms for which to generate hashes. See ALGORITHMS below.

  -b, --batch
     Use batch mode; i.e., get the input from the command line rather than prompting for it. This option should be used with extreme care, since if the input is a password, it will be clearly visible on the command line.

  -e, --echo
     Enable Echo mode; i.e. when the user is prompted for input, the characters she types are echoed on the screen

  -f FILE, --file FILE
     Read the input from FILE

  -h, --help
     Show a short usage summary.       

ALGORITHMS
  mkroesti defines the following keywords to identify distinct hash algorithms:

  base64
  adler32
  crc32
  crc32b
  crypt            local crypt()
  crypt-md5        md5-based crypt (hash starts with $1$)
  crypt-apr1       md5-based crypt, Apache variant (hash starts with $apr1$)
  crypt-blowfish   blowfish-based crypt (hash starts with $2a$)
  md2
  md4
  md5
  sha-0        original, superseded by sha-1
  sha-1
  sha-224
  sha-256
  sha-384
  sha-512
  ripemd       original, superseded by ripemd-160
  ripemd-128
  ripemd-160
  ripemd-256
  ripemd-320
  haval-128-[345]   3, 4 or 5 rounds
  haval-160-[345]
  haval-192-[345]
  haval-224-[345]
  haval-256-[345]
  whirlpool
  tiger-128
  tiger-160
  tiger-192
  tiger2
  snefru
  gost
  windows-lm
  windows-nt
  mysql-password       MySQL's PASSWORD() function

  mkroesti defines the following aliases to refer to sets of hash algorithms

  all
  chksum
  crypt
  sha
  ripemd
  haval
  tiger
  snefru

EXAMPLES

  (1) Prompt the user to interactively provide the input, not echoing the input on the screen. Hashes for all algorithms are generated.
  
    mkroesti 

  (2) Take the input from file foo and generate hashes for the algorithms md5, sha-1 and haval-128 (4 rounds variant)
  
    mkroesti -f foo -a md5,sha-1,haval-128-4

  (3) Take the input from standard input and generate a single hash using the local crypt() system function
  
    cat foo | mkroesti -a crypt

  (4) Use the string "secret" as input and generate hashes for all algorithms of the SHA and RIPEMD family.
  
    mkroesti -b -a sha,ripemd secret

EXIT CODES

  0  success
  1  runtime error
  2  error during parsing of command line arguments

BUGS

  mkroesti is not good at handling large files, because it tries to read its entire input into memory.

  If you find any other bugs, please report them to <mkroesti@herzbube.ch>.

DEPENDENCIES

  mkroesti depends on the following Python modules:

    base64
    hashlib
    crypt
    random
    string
    smbpasswd (see http://barryp.org/software/py-smbpasswd/)
    mhash (see http://labix.org/python-mhash)
    bcrypt (see http://www.mindrot.org/projects/py-bcrypt/)

SEE ALSO

  -

AUTHOR

  Patrick Näf (herzbube@herzbube.ch)

LICENSE

  GPLv2


Analysis
--------
General program flow:
1) Select algorithm(s)
2) Convert program input into algorithm input
   - determine program input encoding: auto-detect, or by specification of command line arguments
   - normalize program input to UTF-8
3) For each selected algorithm, generate hash
   - prepare algorithm input
     - if algorithm does not require specific encoding and/or transformation of input
       - use the original program input as the algorithm input
     - if algorithm requires specific encoding and/or transformation of input
       - if encoding is required: convert normalized UTF-8 input into encoding required by algorithm
       - if transformation (e.g. conversion to upper case) is required: perform transformation
       - use the encoded and/or transformed input as the algorithm input
  - generate hash
  - convert hash into desired output format
4) Output all results


TODO
----
* TODOs in the code
* add support for "algorithm sources"
  * determine which sources are available
  * if an algorithm is available through several sources, automatically select one
  * gracefully handle that an algorithm is not available at all
  * add a command line option to list supported hashes, which ones are available, and which sources provide them
* add support for "digest length"
  * algorithms should be selectable by digest length
  * for instance, there should be an alias "digest-160" that generates all hashes with a digest length of 160 bit
* try to improve handling of large inputs
* find out why adler32 and crc32 checksums (provided by zlib module) are not correct
  * adler32 for "foo": expected = 45018202 (hex, i.e. dec = 1157726722), actual = 42074437 (dec)
  * crc32 for "foo": expected = A5C4FE49 (hex, i.e. dec = 2781150793), actual = -1938594527 (dec)
  * see issue 1202: http://bugs.python.org/issue1202
    * as per standard, the result should always be an unsigned number
    * python 2.x implementation always returns a signed number
* implement missing hashes
  * crypt-apr1
  * crypt-md5
  * ripemd ("ripemd" currently is an alias)
  * haval-*-[45]
    * http://www.theserverpages.com/php/manual/en/ref.mhash.php
  * tiger2
  * mysql-passwd
* add even more hashes
  * HAS-160
  * MDC-2 (probably provided by hashlib)
  * N-Hash
  * RadioGatún
  * HAS-V
  * MASH-1, MASH-2
  * hashemall.com has "3 passes" and "4 passes" variants of tiger-128/160/192; mkroesti currently provides the "3 passes" variant only
* implement handling of encoding, or throw the issue out & add a comment under "BUGS"
* add test suite

Research
--------
* the Python Standard Library
  * provides a couple of modules under the heading "Cryptographic Services" [1]
    * from these I use only the "hashlib" module because it provides all the algorithms of the other modules, and more
      * always present in hashlib: md5, sha-1, sha-224, sha-256, sha-384, sha-512
      * presence of the following depends on the version of the underlying OpenSSL: ripemd-160, sha-0, md2, md4
  * provides a couple of encoding modules
    * "base64" module: provides base64
  * provides the "crypt" module with access to the system's crypt() function
* the module "smbpasswd" [2]; Debian package "python-smbpasswd"; the module provides these algorithms
  * windows-lm, windows-nt
* the module "m2crypto" (MeTooCrypto) [3]; Debian package "python-m2crypto"; is a wrapper for OpenSSL
  * investigate
* the module "mhash" [4]; manually built package "python-mhash"; is a wrapper for the mhash library
  * how to get the python module
    * download
    * unpack tar ball
    * install dependencies (python-dev, libmhash-dev)
    * ./setup.py build
    * ./setup.py install
  * the library/python module provides the following algorithms
    * haval-128, haval-160, haval-192, haval-224, haval-256 (3 rounds variant)
    * ripemd-128, ripemd-256, ripemd-320
    * tiger-128, tiger-160, tiger-192
    * whirlpool
    * snefru-128, snefru-256
    * gost
* the module "mcrypt" [5]; manually built package "python-mcrypt"; is a wrapper for the mcrypt library
  * how to get the python module
    * download
    * unpack tar ball
    * install dependencies (python-dev, libmcrypt-dev)
    * ./setup.py build
    * ./setup.py install
  * what does the library/python module provide?
* the module "bcrypt" [5]; Debian package "python-bcrypt"; the module provides this algorithm
  * crypt-blowfish
* details about the Apache-specific md5 algorithm can be found here [7]; the page mentions that OpenSSL knows the algorithm, therefore I try to use a python wrapper for OpenSSL to get at the algorithm

[1] http://www.python.org/doc/current/library/crypto.html
[2] http://barryp.org/software/py-smbpasswd/
[3] http://chandlerproject.org/Projects/MeTooCrypto
[4] http://labix.org/python-mhash
[5] http://labix.org/python-mcrypt
[6] http://www.mindrot.org/projects/py-bcrypt/
[7] http://httpd.apache.org/docs/trunk/misc/password_encryptions.html

Design
------
* factory that creates algorithm instances based on the name(s) specified on the cmdline
* how do we handle aliases?
  * option 1: factory resolves aliases to the real algorithm names and creates the necessary instances
    * pro
      * alias to algorithm mapping is kept in one place
      * complexity of algorithm class is low
    * con
      * algorithm names appear in several places
      * factory class complexity is slightly higher
  * option 2: each algorithm knows which aliases it belongs to
    * pro
      * algorithm names are kept in one place
      * factory class complexity is low
    * con
      * alias names appear in several places
      * complexity of algorithm class is higher
      * it might also be necessary to extend the aliasing concept into the registry
   * as long as the aliasing concept does not require more than creating multiple instances, option 1 is better


