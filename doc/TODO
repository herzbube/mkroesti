Purpose of this document
------------------------
This document contains a list of minor features and technical stuff that should
be implemented when time permits it. The TODO list is updated frequently as new
ideas crop up during programming.

For a broader view of how the project will develop over time, you should see
the Roadmap document.


Priority 1 (important)
----------------------
- the --codec option was added mainly to handle the border case where binary
  input needs to be converted to string for algorithms like crypt-system (which
  is unfortunate in the first place, the algorithms mkroesti uses should always
  use binary data as input); the --codec option was also added to enable unit
  tests to specify an encoding for their input; now that --codec has been
  implemented, it proves to be a major nuisance, because its usage remains
  unclear in certain situations:
  - currently --codec is ignored if input data is read in binary form and given
    to an algorithm in binary form; this probably does not make sense to a user,
    although it makes sense to me, as I believe that it is not the job of
    mkroesti to recode text files
  - the option is ignored as well if input data is read in string form and
    given to an algorithm in string form; to a user, this probably makes no
    sense, either; from a technical point of view, though, there is no way how
    we can fix this, because regardless of how many re-interpretations we make,
    the input data always ends up in a string in unicode format, and is given
    to the algorithm as such
  - Conclusion: This situation needs to be fixed, somehow. Possible solutions
    1) Remove --codec
    2) Leave the implementation as it is and document the problems sufficiently
    3) Change the implementation so that binary data is re-interpreted when
       --codec is specified; this needs thorough documentation, as well as
       the str->str situation where no conversion is taking place, ever
    4) Add yet another command line argument, --force. This still does not help
       the str->str situation.
  - Before the problem is tackled, the Python 2.6 implementation should be
    revisited, fixed and tested. 
- test with Python 2.6 what works and what doesn't after Python 3 changes have
  been implemented; things that probably need fixing: handling of text vs. data
  (i.e. usage of the Python 3 type "bytes"); things that should be ok: absolute
  imports; new "except as" syntax (should have been backported to Python 2.6; to
  which version? specify that version in the minimum requirements section in
  README); print() as a function (we use "from __future import"); handling of
  dict.keys(); replacement of callable() by hasattr()
- check if all algorithms return the correct value for needBytesInput()
- experiment how getpass.getpass() interprets the user input; it is currently
  assumed that it uses the current default encoding; an interesting experiment
  would be one where the default encoding is different from what user input
  actually provides, e.g. user input provides UTF-8 but default encoding is
  something like ISO8859-1; write down the results in the Research
- support for encodings is not yet finished; the following things need to be
  done, still:
  - write a set of new test cases
  - add support for encodings in Python 2.6 as well; if not possible, find the
    limitations and specify them in README and MANUAL
  - Note: It seems to be impossible to specify an encoding that will influence
    the interpretation of the command line argument in batch mode; if there is
    an error converting the argument into unicode for storage in sys.argv, using
    the default encoding, the error will cause the interpreter to abort before
    execution even has reached the mkroesti code; the abort message looks like
    this on my Mac Book Pro using Python 3.0.1: "Could not convert argument 5 to string".
    This problem can probably not be fixed, maybe there should be a FAQ for it?
- check if in Python 2.6 sys.stdin.buffer exists and can be used in the same
  way as in Python 3 to read binary data
- fix TODOs in the code
- add more tests
  - write a command line driven test suite that checks whether each algorithm
    produces the expected hash for a well-known input, regardless of the input
    method; there are several goals involved:
    1) Have a test suite that exercises *all* of the supported algorithms at
       least one time
    2) Have a test suite that exercises *all* input methods at least one time
       (use expect for interactive entry)
    3) Last but not least: Have an end-to-end test suite (as opposed to the
       more detailed automated unit tests)
  - add tests to test_main.py for -p, -x and -c
  - write a test case class that accepts a provider in its __init__ and then
    goes on to exercise the provider to make sure that its implementation is
    valid
    -> subclass the testcase and exercise the various concrete providers
  - test deep copying? e.g. provider.getAliasNames() should return a list that
    we can modify, but the next call should return the same list
  - write a test that uses AlgorithmStub and ProviderStub to exercise some
    functionality; see helper setUpProviderStub()


Priority 2 (nice to have)
-------------------------
- try to improve handling of large inputs
- find out why adler32 and crc32 checksums (provided by zlib module) are not correct
  - adler32 for "foo": expected = 45018202 (hex, i.e. dec = 1157726722), actual = 42074437 (dec)
  - crc32 for "foo": expected = A5C4FE49 (hex, i.e. dec = 2781150793), actual = -1938594527 (dec)
  - see issue 1202: http://bugs.python.org/issue1202
    - as per standard, the result should always be an unsigned number
    - python 2.x implementation always returns a signed number


Priority 3 (not important)
-------------------------
- register with PyPI
- check whether in Python 3 the command "python setup.py test --help" still
  prints out the command class' name instead of the command name string used
  to setup the command; file a bug with Distutils if this problem still persists 
